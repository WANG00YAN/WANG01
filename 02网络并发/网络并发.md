# 网络基础概念

##### IP地址
> 功能：确定一台主机的网络路由位置
> 查看本机网络地址命令：ifconfig(linux)、ipconfig(Windows)

> 结构：
> ipv4 点分十进制表示  172.40.91.185 每一个部分取值范围0~255
> ipv6 128位 扩大了地址范围

注意：
> 在同一局域网内的ip都各不相同

##### 域名
> 定义：给网络服务器地址起的名字
> 作用：方便记忆，表达一定的含义
> ping [ip]：测试和某个主机是否联通

##### 端口号
> 作用：端口号是网络地址的一部分，用于区分主机上不同的网络应用程序
> 特点：一个系统中的应用监听的端口号不能重复
> 取值范围：1~65535
>> 1~1023 系统应用或者大众程序监听端口
>> 1024~65535 自用端口，推荐使用10000以上的

# 传输层服务

## 面向连接的传输服务(基于TCP协议的数据传输)
1、传输特征：提供了可靠的数据传输
2、实现手段：在通信前建立数据连接，通信结束要断开
> 三次握手
> > 客户端向服务器发送消息报文请求连接
> > 服务器收到请求后，回复报文确定可以连接
> > 客户端收到回复，发送报文建立连接

## 面向无连接的传输服务(基于UDP协议的数据传输)
1、传输特点：不保证传输的可靠性
2、适用情况：网络较差，对传输可靠性要求不高

# socket套接字编程

## 套接字介绍

1、套接字：实现网络编程进行数据传输的一种技术手段
2、Python实现套接字编程：import socket
3、套接字分类:
> 流式套接字(SOCK_STREAM)：以字节流传输数据，实现tcp网络传输

> 数据报套接字(SOCK_DGRAM)：以数据报形式传输数据，实现udp网络传输

# tcp套接字编程

## 服务端流程

> 1、socket -- 创建套接字
> 2、bind -- 绑定地址
> 3、listen -- 监听
> 4、accept -- 等待客户端连接
> 5、send/recv -- 沟通
> 6、close -- 结束

***1、创建套接字***

```
sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
功能：创建套接字
参数：
    socket_family：   网络地址类型 AF_INET表示ipv4
    socket_type： SOCK_STREAM(流式)、SOCK_DGRAM（数据包）
    proto：   通常为0   选择子协议
返回值：套接字对象
```

***2、绑定地址***
> 本地地址：'localhost','127.0.0.1' -- 别人计算机的客户端访问不来了，只有本机的客户端是可以
> 网络地址：'192.168.79.140' -- 别人和自己都必须通过192.168.79.140这个地址来访问
> 自动获取地址：'0.0.0.0' -- 别人通过192.168.79.140访问
```
sockfd.bind(addr)
功能：绑定本机网络地址
参数：二元元组（ip,port）('0.0.0.0',8888)
```

***3、设置监听***
```
sockfd.listen(n)
功能：将套接字设置为监听套接字，n是确定监听队列的大小
参数：监听队列的大小
```

***4、等待处理客户端连接请求***
```
connfd,addr = sockfd.accept()
功能：阻塞等待处理客户端请求
返回值：connfd：客户端连接套接字
       addr：链接的客户端地址
```

***5、消息收发***
```
data = connfd.recv(buffersize)
功能：接受客户端消息
参数：每次接受消息的大小
返回值：接受到的内容

n = connfd.send(data) 
功能：发送消息
参数：要求发送的内容 bytes格式
返回值：发送的字节shu
```
> encode() 将字符串转化为字节穿
> decode() 将字节串转化为字符串

***6、关闭套接字***
```
sockfd.close()
功能：关闭套接字
```

##### 代码
```
import socket

# 创建tcp套接字
sockfd = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

# 绑定地址
sockfd.bind(('0.0.0.0',8888))

# 设置监听
sockfd.listen(5)

# 阻塞等待链接
print("Wait for connect...")
connfd,addr = sockfd.accept()
print(f"Connect form {addr} ...")

# 收发消息
data = connfd.recv(1024)
print(f"收到：{data}")
connfd.send(b'Thanks')

# 关闭套接字
connfd.close()
sockfd.close()
```
注意：
> 服务端绑定地址也要正确

##　客户端流程

> 1、socket -- 创建套接字
> 2、bind -- 绑定地址(可选)
> 3、connect -- 连接
> 5、send/recv -- 沟通
> 6、close -- 结束

***1、创建套接字***
> 注意：只有相同的套接字才能进行通信

***2、请求连接***
```
sockfd.connect(server_addr)
功能：连接服务器
参数：元组  服务器地址
```

***3、收发消息***
> 注意：防止两段都阻塞，recv，send要配合

***4、关闭套接字***
> sockfd.close()

代码：
```
from socket import *

# 创建tcp套接字
sockfd = socket() # 使用默认参数 -> tcp套接字

# 连接
sockfd.connect(('127.0.0.1',8888))

# 收发消息
data = input("Msg>>")
sockfd.send(data.encode())
data = sockfd.recv(1024)
print("Server:",data.decode())

# 关闭
sockfd.close()
```

注意：
> 客户端连接服务端的时候一定要确保连接地址正确


##### 注意
> 客户端断开连接时，会给服务器端发送一个null

#### 客户端循环发送消息
```
# 收发消息
while True:
    data = input("Msg>>")
    if not data:
        break
    sockfd.send(data.encode())
    data = sockfd.recv(1024)
    print("Server:",data.decode())
```
#### 服务端循环接受消息
```
# 收发消息
while True:
    # 阻塞等待链接
    print("Wait for connect...")
    connfd,addr = sockfd.accept()
    print(f"Connect form {addr} ...")

    while True:
        data = connfd.recv(1024)
        if not data:
           break
        print(f"收到：{data.decode()}")
        connfd.send(b'Thanks')
    connfd.close()
```

#### 网络收发缓冲区
当网络缓冲区里面没内容的时候recv才会阻塞
> 1、网络缓冲区有效的协调了消息的收发速度
> 2、send和recv实际是向缓冲区发送接受消息，当缓冲区不为空recv就不会阻塞

#### tcp粘包
> 原因：tcp以字节流的方式传输，没有消息边界。多次发送的消息被一次接受，此时就会形成粘包。

> 影响：如果每次发送内容都是一个独立的含义，需要接受端独立解析此时粘包会有影响

> 处理方法:
> > 1、人为的添加消息边界
> > 2、控制发送速度

# UDP套接字编程

## 服务端流程
> 1、socket -- 创建套接字
> 2、bind -- 绑定地址
> 3、recvfrom -- 接受  
> 4、sendto -- 发送
> 5、close -- 关闭套接字

***1、创建数据报套接字***
```
sockfd = socket(AF_INET,SOCK_DGRAM)
```

***2、绑定地址***
```
sockfd.bind(addr)
```

***3、消息收发***
```
data,addr = sockfd.recvfrom(buffersize)
功能：接受udp消息
参数：每次接受多少字节
返回值：data    接受到的内容
       addr    目标地址

n = sockfd.sento(data,addr)
功能：发送udp消息
参数：data 发送的内容
    addr 目标地址
返回值：发送的字节数
```

***4、关闭套接字***
```
sockfd.close()
```

代码：
```
from socket import *

# 创建套接字
sockfd = socket(AF_INET,SOCK_DGRAM)

# 绑定地址
sockfd.bind(('0.0.0.0',8888))

# 收发消息
while True:
    data,addr = sockfd.recvfrom(1024)
    print(data.decode())
    sockfd.sendto(b"Thanks",addr)
    
# 关闭套接字
sockfd.close()
```

## 服务端流程
> 1、socket -- 创建套接字
> 3、sendto -- 发送
> 4、recvfrom -- 接受  
> 5、close -- 关闭套接字

注：数据报消息传输有消息边界，不会产生粘包问题

# socket套接字属性
> sockfd.type -- 套接字类型(流式、数据报)
> sockfd.family -- 套接字的地址类型(ipv4、ipv6)
> sockfd.getsockname() -- 获取绑定地址
> sockfd.fileno() -- 文件描述符
> sockfd.getpeername() -- 连接端地址(连接套接字可以使用)

> sockfd.setsockopt(level,option,value)
```
功能：设置套接字选项 SOL_SOCKET
参数：level 选择类别
    option 具体选项内容
    value 选项值
sockfd.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) # 当意外断开，绑定的端口会被立刻回收
```

# UDP套接字广播
brodcast: 广播地址

> ·广播定义：一端发送多点接受
> ·广播地址：每个网络的最大地址为发送广播的地址，向该地址发送，则网段所有主机都能接收

# TCP套接字之HTTP传输

## HTTP协议（超文本传输协议）
1、用途：网页获取，数据传输
2、特点
3、网页请求过程
> 1、客户端(浏览器)通过tcp传输，发送http请求给服务端
> 2、服务端接受到http请求后进行解析
> 3、服务端处理请求内容，组织响应内容
> 4、服务器将响应内容以http响应格式发送给浏览器
> 5、浏览器接受到响应内容，解析展示

![http请求过程](./data/http.jpg)

### HTTP请求(request)

***1、请求行***
具体的请求类别和请求内容
```
GET         /       HTTP/1.1
请求类别    请求内容   协议版本
```
请求类别：每个请求类别表示要做不同的事情
> get: 获取网络资源
> post: 提交一定的信息，得到反馈
> head: 只获取网络资源的响应头
> put: 更新服务器资源
> delete: 删除服务器资源

***2、请求头***
对请求的进一步解释和描述
***3、空行***
***4、请求体***
请求参数或者提交内容

注：请求行和空行一定要有，另外两个可以没有

### http响应(response)
响应格式：响应行，响应头，空行，响应体

***1、响应行***
返回基本的响应情况
```
HTTP/1.1    200     OK
版本信息    响应码  附加信息
```
响应码：
> 1xx: 提示信息，表示请求被接受
> 2xx: 响应成功
> 3xx: 响应需要进一步操作，重定向
> 4xx: 客户端错误
> 5xx: 服务器错误

<a herf='http://www.javashuo.com/article/p-vtkttzmg-cp.html'>响应码介绍</a>

***2、响应头***
对响应内容的描述
***3、响应体***
响应的主体内容


##### 代码：
```
响应行：response = "HTTP/1.1 200 OK\r\n"    
响应头：response+="Content-Type:text/html\r\n"
空行：response+="\r\n"
响应体：response+=f.read()
```

# struct模块的使用
##### 1、原理：
>将一组简单数据进行打包。转换为bytes格式发送。或者将一组bytes格式数据，进行解析

> 可以在不同语言之间通信

##### 2、接口使用
```
Struct(fmt)
功能：生成结构化数据
参数：fmt   定制数据结构

st.pack(v1,v2,v3...)
功能：将一组数据按照指定格式打包转换为bytes
参数：要打包的数据
返回值：bytes字节串

st.unpack(bytes_data)
功能：将bytes字节串按照指定的格式解析
参数：要解析的字节串
返回值：解析后的内容
```
代码实例：
```
import struct
st = struct.Struct('i4sf') # 第一个为整形，第二个为四个字节串，第三个是浮点型
data = st.pack(1,b'asdd',1.25)
# 结果：b'\x01\x00\x00\x00sssd33\xd3?'
```

# 多任务编程
1.意义：充分利用计算机多核资源，提高程序的运行效率
2.实现方案：多进程，多线程
3.并行与并发

> 并发：同事处理多个任务，内核在任务间不断的切换达到好像多个任务被同时执行的效果，实际每个时刻只有一个任务占有内核
> 并行：多个任务利用计算机的多核资源在同事执行，此时多个任务间为并行关系

注：并发对于IO密集型程序(等待的时间多)能很好的提高效率，对计算密集型程序的效率提高的比较低。
# 进程

##　进程理论基础
***1、定义：程序在计算中的一次进程***
> ·程序是一个可执行，是静态的占有磁盘
> ·进程是一个动态的过程描述，占用计算机运行资源，有一定的生命周期。

***2、系统中如何产生一个进程***

> 1.用户空间通过调用程序接口或者命令发起请求
> 2.操作系统接收用户请求，开始创建进程
> 3.操作系统调配计算机资源，确定进程状态
> 4.操作系统将创建的进程提供给用户使用

***3、进程基本概念***

> ·cpu时间片：如果一个进程占有cpu内核，则称这个进行在CPU时间片上。
> ·PCB(进程控制块)：在内存中开辟一块空间，用于存放进程的基本信息，也用于系统查找识别进程。
> ·进程ID(PID)：系统为每个进程分配的一个大于0的整数作为进程ID。每个进程ID不重复
> > linux查看进程ID的命令：ps -aux
> ·父子进程：系统中每个进程（除了系统初始化进程）都有唯一的父进程，可以有0个或者多个子进程。父子进程关系便于进程管理
> > 查看进程树：pstree

***4、进程状态***
· 三态
> 就绪态：进程具备执行条件，等待分配cpu资源
> 执行态：进程占有cpu时间片正在运行
> 阻塞等待态：进程暂时停止运行，让出CPU

·五态(在三态的基础上增加新建和终止)
> 新建：创建一个进程，获取资源的过程
> 终止：进程结束，释放资源的过程


***5、进程的运行特征***
> 1.进程可以使用计算机多核资源
> 2、进程是计算机分配资源的最小单位
> 3、进程之间的运行互不影响，各自独立
> 4、**每个进程拥有独立的空间，各自使用自己的空间资源**

# 基于fork的多进程编程

**pid = os.fork()**
> 功能：创建新的进程
> 返回值：整数，如果创建进程失败返回一个负数，如果成功则在原有的进程中返回新进程PID，在新进程中返回0


> 子进程是从fork语句的下一条语句开始执行

![创建子进程的过程](./data/fork.jpg)

代码：
```
import os
pid = os.fork()
if pid<0:
    print("创建失败")
elif pid == 0:
    print("这是新进程")
else:
    print('这个是老进程')
```

注意：
> ·子进程会复制父进程全部内存空间，从fork下一句开始执行
> ·父子进程各自独立运行，运行顺序不一定
> ·利用父子进程fork返回值的区别，配合if结构让父子进程执行不同的内容几乎是固定搭配
> ·父子进程各自有个自的特征比如PID，PCB命令集等
> ·父进程fork之前开辟的空间子进程同样拥有，父子进程对各自空间的操作不会相互影响

# 进程相关函数
> os.getpid()
> 功能：获取一个进程的pid值
> 返回值：当前进程的pid

> os.getppid()
> 功能：获取父进程的pid
> 返回值：父进程的pid值

> os._exit(status)
> 功能：结束一个进程
> 参数：进程的终止状态

> sys.exit([status])
> 功能：退出进程
> 参数：整数 表示退出状态
> 字符串 表示退出时打印内容

注意：
> ·父子进程的退出不会影响另一个

***1、孤儿进程***
> 如果一个进程的父进程先结束了，那么子进程会被系统派出的专有进程收养。这就是孤儿进程的产生。

***2、僵尸进程***
> 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会变成僵尸进程。

> 特点：僵尸进程虽然结束，但是会存留部分pcb在内存中，大量的僵尸进程会浪费系统的内存资源

***3、如何避免僵尸进程产生***
###### 使用wait函数处理子进程退出
```
pid,status = os.wait()
功能：在父进程中阻塞等待处理子进程退出
返回值：pid 退出的子进程的pid
       status 子进程的退出状态*256
```

###### 创建二级子进程处理僵尸
> 1、父进程创建子进程，等待回收子进程
> 2、子进程创建二级子进程然后退出
> 3、二级子进程成为孤儿进程，执行事件

```
pid = os.fork()
if pid == 0:    #一级子进程
    p = os.fork()
    if p == 0:  #二级子进程
        执行事件2
    else:
        sys.exit()  #退出一级子进程
else:   #父进程
    执行事件1
```

###### 通过信号处理子进程退出
> 原理：子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出.
> 方法：使用signal模块在父进程创建子进程前写如下语句

```
import signal
signal.signal(signal.SIGCHLD,signal.SIG_IGM)
```
> 特点：非阻塞，不会影响父进程运行，可以处理所有子进程退出

# 完成群聊聊天室
功能：
> ·有人进入聊天室需要输入姓名，姓名不能重复
> ·有人进入聊天室时会收到其他人会收到通知：xxx进入了聊天室
> ·一个人发消息，其他人会收到消息
> ·有人退出聊天室，其他人会收到：xx：xxxxxxx
> ·扩展功能：服务器可以向所有用户发送公告：管理员消息：xxxx

#　聊天室思路分析

1、需求分析：干什么达到什么效果？

2、技术点的确认：
```
·数据如何流动
    转发：客户端->服务端->其他客户端
·网络模型如何构建
    转发：构建udp数据传输，离线也可以发
·用户信息在哪维护，怎么维护
    服务端：{name:address}
           [(name,address),]
·随意收发消息如何避免阻塞
    多进程，收发分别是用不同的进程来实现
```

3、结构设置的注意事项

> 采用什么封装：函数
> 编写一个功能测试一个功能
> 注意注释和结构的设计


![聊天室结构框图](./data/聊天室.jpg)
4、分析功能模块
> ·网络搭建

> ·进入聊天室
```
客户端：
    ·循环请求进入聊天室
    ·得到服务器返回
    ·允许通过跳出循环，不允许继续请求

服务端：
    ·循环就受客户端发出的登录请求
    ·判断该用户请求能否通过
    ·给用户发反馈
```

> ·聊天
```
·客户端：
    创建新的进程，一个进程循环发消息，一个进程循环收消息
·服务端：
    接受请求，判断请求类型，将消息转发给其他人。
```

> ·退出聊天室
> ·管理员消息

5、通信协议设置
```
·进入聊天室：L
·聊天：C
·退出：Q
·服务器返回：OK 成功，其他表示失败
·客户端收到EXIT：退出进程
```

注意：
```
·客户端在退出时结束了发送消息的进程但是接受消息的进程没有关闭。
·服务端弄一个管理员进程拿不到用户的请求，那么可以向自己发起一个请求,让请求进程处理管理员的消息，从而达到向客户端发消息的目的。
```

